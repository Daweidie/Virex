#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "parser/parser.h"
#include "ast/ast.h"
#include "ast/bytecode.h"
#include "ast/type_inference.h"
#include "compiler/compiler.h"
extern FILE* yyin;
extern ASTNode* root;
void analyze_ast(TypeInferenceContext* ctx, ASTNode* node);
void create_lib_files();
void save_bytecode_to_file(ByteCodeList* list, const char* filename);
int main(int argc, char **argv) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <input.vix> [-o output_file] [-b bytecode_file] [-c cpp_file] or %s init\n", argv[0], argv[0]);
        fprintf(stderr, "       %s <input.vbtc> -c <output.cpp>\n", argv[0]);
        return 1;
    }
    if (strcmp(argv[1], "init") == 0) {
        create_lib_files();
        return 0;
    }
    char* output_filename = NULL;
    char* bytecode_filename = NULL;
    char* cpp_filename = NULL;
    int is_vbtc_file = strlen(argv[1]) > 5 && strcmp(argv[1] + strlen(argv[1]) - 5, ".vbtc") == 0;
    int is_compile_mode = 0;
    if (is_vbtc_file) {
        for (int i = 2; i < argc; i++) {
            if (strcmp(argv[i], "-c") == 0) {
                is_compile_mode = 1;
                if (i + 1 < argc) {
                    cpp_filename = argv[i + 1];
                    i++;
                } else {
                    fprintf(stderr, "Error: -c option requires a cpp file name\n");
                    return 1;
                }
                break;
            }
        }
    }
    
    if (is_compile_mode && is_vbtc_file) {
        return compile_vbtc_to_cpp(argv[1], cpp_filename);
    }
    for (int i = 2; i < argc; i++) {
        if (strcmp(argv[i], "-o") == 0) {
            if (i + 1 < argc) {
                output_filename = argv[i + 1];
                i++; 
            } else {
                fprintf(stderr, "Error: -o option requires a filename\n");
                return 1;
            }
        } else if (strcmp(argv[i], "-b") == 0) {
            if (i + 1 < argc) {
                bytecode_filename = argv[i + 1];
                i++;
            } else {
                fprintf(stderr, "Error: -b option requires a filename\n");
                return 1;
            }
        } else if (strcmp(argv[i], "-c") == 0) {
            i++;
        } else {
            fprintf(stderr, "Unknown option: %s\n", argv[i]);
            fprintf(stderr, "Usage: %s <input.vix> [-o output_file] [-b bytecode_file] [-c cpp_file]\n", argv[0]);
            return 1;
        }
    }
    
    FILE* input_file = fopen(argv[1], "r");
    if (!input_file) {
        perror("Failed to open file");
        return 1;
    }
    
    yyin = input_file;
    
    int result = yyparse();
    
    if (result == 0) {
        ByteCodeGen* gen = create_bytecode_gen();
        generate_bytecode(gen, root);
        if (bytecode_filename != NULL) {
            char vbtc_filename[256];
            if (strstr(bytecode_filename, ".vbtc") == NULL) {
                snprintf(vbtc_filename, sizeof(vbtc_filename), "%s.vbtc", bytecode_filename);
            } else {
                strcpy(vbtc_filename, bytecode_filename);
            }
            save_bytecode_to_file(gen->bytecode, vbtc_filename);
        }
        
        if (output_filename != NULL) {
            char cpp_filename[256];
            if (strstr(output_filename, ".cpp") == NULL) {
                snprintf(cpp_filename, sizeof(cpp_filename), "%s.cpp", output_filename);
            } else {
                strcpy(cpp_filename, output_filename);
            }
            
            FILE* output_file = fopen(cpp_filename, "w");
            if (!output_file) {
                perror("Failed to create output file");
                free_bytecode_gen(gen);
                fclose(input_file);
                return 1;
            }
            TypeInferenceContext* type_ctx = create_type_inference_context();
            analyze_ast(type_ctx, root);
            compile_to_cpp_with_types(gen, type_ctx, output_file);
            free_type_inference_context(type_ctx);
            fclose(output_file);
            char compile_command[512];
            snprintf(compile_command, sizeof(compile_command), "g++ -std=c++17 %s -o %s", cpp_filename, output_filename);
            int compile_result = system(compile_command);
            remove(cpp_filename);
            if (compile_result == 0) {
            } else {
                printf("Failed to compile to executable\n");
            }
        } else if (bytecode_filename == NULL) {
            printf("AST generated by bison and flex:\n");
            print_ast(root, 0);
            print_bytecode(gen->bytecode);
        }
        
        free_bytecode_gen(gen);
    } else {
        printf("Parsing failed!\n");
    }
    
    if (root) {
        free_ast(root);
    }
    
    fclose(input_file);
    return result;
}

void save_bytecode_to_file(ByteCodeList* list, const char* filename) {
    FILE* file = fopen(filename, "w");
    if (!file) {
        perror("Failed to create bytecode file");
        return;
    }
    
    for (int i = 0; i < list->count; i++) {
        switch (list->codes[i].op) {
            case BC_LOAD_CONST_INT:
                fprintf(file, "LOAD_CONST_INT %lld\n", list->codes[i].operand.int_value);
                break;
            case BC_LOAD_CONST_FLOAT:
                fprintf(file, "LOAD_CONST_FLOAT %f\n", list->codes[i].operand.float_value);
                break;
            case BC_LOAD_CONST_STRING:
                fprintf(file, "LOAD_CONST_STRING \"%s\"\n", list->codes[i].operand.string_value);
                break;
            case BC_LOAD_NAME:
                fprintf(file, "LOAD_NAME %d\n", list->codes[i].operand.var_index);
                break;
            case BC_STORE_NAME:
                fprintf(file, "STORE_NAME %d\n", list->codes[i].operand.var_index);
                break;
            case BC_INPUT:
                fprintf(file, "INPUT\n");
                break;
            case BC_TOINT:
                fprintf(file, "TOINT\n");
                break;
            case BC_PRINT:
                fprintf(file, "PRINT\n");
                break;
            case BC_BINARY_ADD:
                fprintf(file, "BINARY_ADD\n");
                break;
            case BC_BINARY_SUB:
                fprintf(file, "BINARY_SUB\n");
                break;
            case BC_BINARY_MUL:
                fprintf(file, "BINARY_MUL\n");
                break;
            case BC_BINARY_DIV:
                fprintf(file, "BINARY_DIV\n");
                break;
            case BC_BINARY_MOD:
                fprintf(file, "BINARY_MOD\n");
                break;
            case BC_BINARY_POW:
                fprintf(file, "BINARY_POW\n");
                break;
            case BC_UNARY_MINUS:
                fprintf(file, "UNARY_MINUS\n");
                break;
            case BC_UNARY_PLUS:
                fprintf(file, "UNARY_PLUS\n");
                break;
            case BC_BINARY_CONCAT:
                fprintf(file, "BINARY_CONCAT\n");
                break;
            case BC_BINARY_REPEAT:
                fprintf(file, "BINARY_REPEAT\n");
                break;
        }
    }
    
    fclose(file);
}

void analyze_ast(TypeInferenceContext* ctx, ASTNode* node) {
    if (!node) return;
    
    switch (node->type) {
        case AST_PROGRAM:
            for (int i = 0; i < node->data.program.statement_count; i++) {
                analyze_ast(ctx, node->data.program.statements[i]);
            }
            break;
            
        case AST_ASSIGN:
            infer_type(ctx, node);
            analyze_ast(ctx, node->data.assign.left);
            analyze_ast(ctx, node->data.assign.right);
            break;
            
        case AST_PRINT:
            analyze_ast(ctx, node->data.print.expr);
            break;
            
        case AST_BINOP:
            analyze_ast(ctx, node->data.binop.left);
            analyze_ast(ctx, node->data.binop.right);
            break;
            
        case AST_UNARYOP:
            analyze_ast(ctx, node->data.unaryop.expr);
            break;
            
        default:
            break;
    }
}

void create_lib_files() {
#ifdef _WIN32
    system("mkdir lib 2>nul");
#else
    system("mkdir -p lib 2>/dev/null");
#endif
    FILE* vcore_file = fopen("lib/vcore.hpp", "w");
    if (vcore_file) {
        fprintf(vcore_file, "#ifndef VCORE_HPP\n");
        fprintf(vcore_file, "#define VCORE_HPP\n\n");
        fprintf(vcore_file, "#include <iostream>\n");
        fprintf(vcore_file, "#include <string>\n\n");
        fprintf(vcore_file, "namespace vcore {\n\n");
        fprintf(vcore_file, "    // 模板函数，可以打印任何类型的数据\n");
        fprintf(vcore_file, "    template<typename T>\n");
        fprintf(vcore_file, "    void print(const T& value) {\n");
        fprintf(vcore_file, "        std::cout << value << std::endl;\n");
        fprintf(vcore_file, "    }\n\n");
        fprintf(vcore_file, "    // 重载模板函数，专门处理bool类型，以打印\"true\"或\"false\"而不是0或1\n");
        fprintf(vcore_file, "    template<>\n");
        fprintf(vcore_file, "    inline void print<bool>(const bool& value) {\n");
        fprintf(vcore_file, "        std::cout << (value ? \"true\" : \"false\") << std::endl;\n");
        fprintf(vcore_file, "    }\n\n");
        fprintf(vcore_file, "    // 重载模板函数，专门处理char*类型，以避免空指针问题\n");
        fprintf(vcore_file, "    template<>\n");
        fprintf(vcore_file, "    inline void print<char*>(char* const& value) {\n");
        fprintf(vcore_file, "        if (value == nullptr) {\n");
        fprintf(vcore_file, "            std::cout << \"nullptr\" << std::endl;\n");
        fprintf(vcore_file, "        } else {\n");
        fprintf(vcore_file, "            std::cout << value << std::endl;\n");
        fprintf(vcore_file, "        }\n");
        fprintf(vcore_file, "    }\n\n");
        fprintf(vcore_file, "    // 重载模板函数，专门处理const char*类型，以避免空指针问题\n");
        fprintf(vcore_file, "    template<>\n");
        fprintf(vcore_file, "    inline void print<const char*>(const char* const& value) {\n");
        fprintf(vcore_file, "        if (value == nullptr) {\n");
        fprintf(vcore_file, "            std::cout << \"nullptr\" << std::endl;\n");
        fprintf(vcore_file, "        } else {\n");
        fprintf(vcore_file, "            std::cout << value << std::endl;\n");
        fprintf(vcore_file, "        }\n");
        fprintf(vcore_file, "    }\n\n");
        fprintf(vcore_file, "    // 重载模板函数，专门处理std::string类型\n");
        fprintf(vcore_file, "    template<>\n");
        fprintf(vcore_file, "    inline void print<std::string>(const std::string& value) {\n");
        fprintf(vcore_file, "        std::cout << value << std::endl;\n");
        fprintf(vcore_file, "    }\n\n");
        fprintf(vcore_file, "    template<typename T, typename... Args>\n");
        fprintf(vcore_file, "    void print(const T& first, const Args&... args) {\n");
        fprintf(vcore_file, "        std::cout << first;\n");
        fprintf(vcore_file, "        if constexpr (sizeof...(args) > 0) {\n");
        fprintf(vcore_file, "            std::cout << \" \";\n");
        fprintf(vcore_file, "            print(args...);\n");
        fprintf(vcore_file, "        } else {\n");
        fprintf(vcore_file, "            std::cout << std::endl;\n");
        fprintf(vcore_file, "        }\n");
        fprintf(vcore_file, "    }\n\n");
        fprintf(vcore_file, "    template<typename T>\n");
        fprintf(vcore_file, "    T add(const T& a, const T& b) {\n");
        fprintf(vcore_file, "        return a + b;\n");
        fprintf(vcore_file, "    }\n\n");
        fprintf(vcore_file, "    template<typename T>\n");
        fprintf(vcore_file, "    T sub(const T& a, const T& b) {\n");
        fprintf(vcore_file, "        return a - b;\n");
        fprintf(vcore_file, "    }\n\n");
        fprintf(vcore_file, "    template<typename T>\n");
        fprintf(vcore_file, "    T mul(const T& a, const T& b) {\n");
        fprintf(vcore_file, "        return a * b;\n");
        fprintf(vcore_file, "    }\n\n");
        fprintf(vcore_file, "    template<typename T>\n");
        fprintf(vcore_file, "    T div(const T& a, const T& b) {\n");
        fprintf(vcore_file, "        return a / b;\n");
        fprintf(vcore_file, "    }\n");
        fprintf(vcore_file, "}\n\n");
        fprintf(vcore_file, "#endif\n");
        fclose(vcore_file);
    }
    FILE* vtypes_file = fopen("lib/vtypes.hpp", "w");
    if (vtypes_file) {
        fprintf(vtypes_file, "#ifndef VTYPES_HPP\n");
        fprintf(vtypes_file, "#define VTYPES_HPP\n\n");
        fprintf(vtypes_file, "#include <string>\n");
        fprintf(vtypes_file, "#include <iostream>\n\n");
        fprintf(vtypes_file, "namespace vtypes {\n\n");
        fprintf(vtypes_file, "class VString : public std::string {\n");
        fprintf(vtypes_file, "public:\n");
        fprintf(vtypes_file, "    // Constructors\n");
        fprintf(vtypes_file, "    VString() : std::string() {}\n");
        fprintf(vtypes_file, "    VString(const std::string& str) : std::string(str) {}\n");
        fprintf(vtypes_file, "    VString(const char* str) : std::string(str) {}\n");
        fprintf(vtypes_file, "    VString(const VString& other) : std::string(other) {}\n\n");
        fprintf(vtypes_file, "    // String concatenation operator\n");
        fprintf(vtypes_file, "    VString operator+(const VString& other) const {\n");
        fprintf(vtypes_file, "        return VString(static_cast<const std::string&>(*this) + static_cast<const std::string&>(other));\n");
        fprintf(vtypes_file, "    }\n\n");
        fprintf(vtypes_file, "    // String repetition operator\n");
        fprintf(vtypes_file, "    VString operator*(int times) const {\n");
        fprintf(vtypes_file, "        VString result;\n");
        fprintf(vtypes_file, "        for (int i = 0; i < times; ++i) {\n");
        fprintf(vtypes_file, "            result += *this;\n");
        fprintf(vtypes_file, "        }\n");
        fprintf(vtypes_file, "        return result;\n");
        fprintf(vtypes_file, "    }\n\n");
        fprintf(vtypes_file, "    // Assignment operators\n");
        fprintf(vtypes_file, "    VString& operator+=(const VString& other) {\n");
        fprintf(vtypes_file, "        static_cast<std::string&>(*this) += other;\n");
        fprintf(vtypes_file, "        return *this;\n");
        fprintf(vtypes_file, "    }\n\n");
        fprintf(vtypes_file, "    VString& operator=(const VString& other) {\n");
        fprintf(vtypes_file, "        static_cast<std::string&>(*this) = other;\n");
        fprintf(vtypes_file, "        return *this;\n");
        fprintf(vtypes_file, "    }\n\n");
        fprintf(vtypes_file, "    // Stream output operator\n");
        fprintf(vtypes_file, "    friend std::ostream& operator<<(std::ostream& os, const VString& str) {\n");
        fprintf(vtypes_file, "        os << static_cast<const std::string&>(str);\n");
        fprintf(vtypes_file, "        return os;\n");
        fprintf(vtypes_file, "    }\n");
        fprintf(vtypes_file, "};\n\n");
        fprintf(vtypes_file, "}\n\n");
        fprintf(vtypes_file, "#endif\n");
        fclose(vtypes_file);
    }
}

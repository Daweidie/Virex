#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "parser/parser.h"
#include "ast/ast.h"
#include "ast/bytecode.h"
#include "ast/type_inference.h"
#include "compiler/compiler.h"
extern FILE* yyin;
extern ASTNode* root;
void analyze_ast(TypeInferenceContext* ctx, ASTNode* node);
void create_lib_files();

int main(int argc, char **argv) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <input.vix> [-o output_file] or %s init\n", argv[0], argv[0]);
        return 1;
    }
    if (strcmp(argv[1], "init") == 0) {
        create_lib_files();
        return 0;
    }
    char* output_filename = NULL;
    for (int i = 2; i < argc; i++) {
        if (strcmp(argv[i], "-o") == 0) {
            if (i + 1 < argc) {
                output_filename = argv[i + 1];
                i++; 
            } else {
                fprintf(stderr, "Error: -o option requires a filename\n");
                return 1;
            }
        } else {
            fprintf(stderr, "Unknown option: %s\n", argv[i]);
            fprintf(stderr, "Usage: %s <input.vix> [-o output_file]\n", argv[0]);
            return 1;
        }
    }
    
    FILE* input_file = fopen(argv[1], "r");
    if (!input_file) {
        perror("Failed to open file");
        return 1;
    }
    
    yyin = input_file;
    
    int result = yyparse();
    
    if (result == 0) {
        ByteCodeGen* gen = create_bytecode_gen();
        generate_bytecode(gen, root);
        if (output_filename != NULL) {
            char cpp_filename[256];
            if (strstr(output_filename, ".cpp") == NULL) {
                snprintf(cpp_filename, sizeof(cpp_filename), "%s.cpp", output_filename);
            } else {
                strcpy(cpp_filename, output_filename);
            }
            
            FILE* output_file = fopen(cpp_filename, "w");
            if (!output_file) {
                perror("Failed to create output file");
                free_bytecode_gen(gen);
                fclose(input_file);
                return 1;
            }
            TypeInferenceContext* type_ctx = create_type_inference_context();
            analyze_ast(type_ctx, root);
            compile_to_cpp_with_types(gen, type_ctx, output_file);
            free_type_inference_context(type_ctx);
            fclose(output_file);
            char compile_command[512];
            snprintf(compile_command, sizeof(compile_command), "g++ -std=c++17 %s -o %s", cpp_filename, output_filename);
            int compile_result = system(compile_command);
            remove(cpp_filename);
            if (compile_result == 0) {
            } else {
                printf("Failed to compile to executable\n");
            }
        } else {
            printf("AST generated by bison and flex:\n");
            print_ast(root, 0);
            print_bytecode(gen->bytecode);
        }
        
        free_bytecode_gen(gen);
    } else {
        printf("Parsing failed!\n");
    }
    
    if (root) {
        free_ast(root);
    }
    
    fclose(input_file);
    return result;
}
void analyze_ast(TypeInferenceContext* ctx, ASTNode* node) {
    if (!node) return;
    
    switch (node->type) {
        case AST_PROGRAM:
            for (int i = 0; i < node->data.program.statement_count; i++) {
                analyze_ast(ctx, node->data.program.statements[i]);
            }
            break;
            
        case AST_ASSIGN:
            infer_type(ctx, node);
            analyze_ast(ctx, node->data.assign.left);
            analyze_ast(ctx, node->data.assign.right);
            break;
            
        case AST_PRINT:
            analyze_ast(ctx, node->data.print.expr);
            break;
            
        case AST_BINOP:
            analyze_ast(ctx, node->data.binop.left);
            analyze_ast(ctx, node->data.binop.right);
            break;
            
        case AST_UNARYOP:
            analyze_ast(ctx, node->data.unaryop.expr);
            break;
            
        default:
            break;
    }
}

void create_lib_files() {
    system("mkdir lib");
    FILE* vcore_file = fopen("lib/vcore.hpp", "w");
    if (vcore_file) {
        fprintf(vcore_file, "#ifndef VCORE_HPP\n");
        fprintf(vcore_file, "#define VCORE_HPP\n\n");
        fprintf(vcore_file, "#include <iostream>\n");
        fprintf(vcore_file, "#include <string>\n\n");
        fprintf(vcore_file, "namespace vcore {\n\n");
        fprintf(vcore_file, "    // 模板函数，可以打印任何类型的数据\n");
        fprintf(vcore_file, "    template<typename T>\n");
        fprintf(vcore_file, "    void print(const T& value) {\n");
        fprintf(vcore_file, "        std::cout << value << std::endl;\n");
        fprintf(vcore_file, "    }\n\n");
        fprintf(vcore_file, "    // 重载模板函数，专门处理bool类型，以打印\"true\"或\"false\"而不是0或1\n");
        fprintf(vcore_file, "    template<>\n");
        fprintf(vcore_file, "    inline void print<bool>(const bool& value) {\n");
        fprintf(vcore_file, "        std::cout << (value ? \"true\" : \"false\") << std::endl;\n");
        fprintf(vcore_file, "    }\n\n");
        fprintf(vcore_file, "    // 重载模板函数，专门处理char*类型，以避免空指针问题\n");
        fprintf(vcore_file, "    template<>\n");
        fprintf(vcore_file, "    inline void print<char*>(char* const& value) {\n");
        fprintf(vcore_file, "        if (value == nullptr) {\n");
        fprintf(vcore_file, "            std::cout << \"nullptr\" << std::endl;\n");
        fprintf(vcore_file, "        } else {\n");
        fprintf(vcore_file, "            std::cout << value << std::endl;\n");
        fprintf(vcore_file, "        }\n");
        fprintf(vcore_file, "    }\n\n");
        fprintf(vcore_file, "    // 重载模板函数，专门处理const char*类型，以避免空指针问题\n");
        fprintf(vcore_file, "    template<>\n");
        fprintf(vcore_file, "    inline void print<const char*>(const char* const& value) {\n");
        fprintf(vcore_file, "        if (value == nullptr) {\n");
        fprintf(vcore_file, "            std::cout << \"nullptr\" << std::endl;\n");
        fprintf(vcore_file, "        } else {\n");
        fprintf(vcore_file, "            std::cout << value << std::endl;\n");
        fprintf(vcore_file, "        }\n");
        fprintf(vcore_file, "    }\n\n");
        fprintf(vcore_file, "    // 重载模板函数，专门处理std::string类型\n");
        fprintf(vcore_file, "    template<>\n");
        fprintf(vcore_file, "    inline void print<std::string>(const std::string& value) {\n");
        fprintf(vcore_file, "        std::cout << value << std::endl;\n");
        fprintf(vcore_file, "    }\n\n");
        fprintf(vcore_file, "    template<typename T, typename... Args>\n");
        fprintf(vcore_file, "    void print(const T& first, const Args&... args) {\n");
        fprintf(vcore_file, "        std::cout << first;\n");
        fprintf(vcore_file, "        if constexpr (sizeof...(args) > 0) {\n");
        fprintf(vcore_file, "            std::cout << \" \";\n");
        fprintf(vcore_file, "            print(args...);\n");
        fprintf(vcore_file, "        } else {\n");
        fprintf(vcore_file, "            std::cout << std::endl;\n");
        fprintf(vcore_file, "        }\n");
        fprintf(vcore_file, "    }\n\n");
        fprintf(vcore_file, "    template<typename T>\n");
        fprintf(vcore_file, "    T add(const T& a, const T& b) {\n");
        fprintf(vcore_file, "        return a + b;\n");
        fprintf(vcore_file, "    }\n\n");
        fprintf(vcore_file, "    template<typename T>\n");
        fprintf(vcore_file, "    T sub(const T& a, const T& b) {\n");
        fprintf(vcore_file, "        return a - b;\n");
        fprintf(vcore_file, "    }\n\n");
        fprintf(vcore_file, "    template<typename T>\n");
        fprintf(vcore_file, "    T mul(const T& a, const T& b) {\n");
        fprintf(vcore_file, "        return a * b;\n");
        fprintf(vcore_file, "    }\n\n");
        fprintf(vcore_file, "    template<typename T>\n");
        fprintf(vcore_file, "    T div(const T& a, const T& b) {\n");
        fprintf(vcore_file, "        return a / b;\n");
        fprintf(vcore_file, "    }\n");
        fprintf(vcore_file, "}\n\n");
        fprintf(vcore_file, "#endif\n");
        fclose(vcore_file);
    }
    FILE* vtypes_file = fopen("lib/vtypes.hpp", "w");
    if (vtypes_file) {
        fprintf(vtypes_file, "#ifndef VTYPES_HPP\n");
        fprintf(vtypes_file, "#define VTYPES_HPP\n\n");
        fprintf(vtypes_file, "#include <string>\n");
        fprintf(vtypes_file, "#include <iostream>\n\n");
        fprintf(vtypes_file, "namespace vtypes {\n\n");
        fprintf(vtypes_file, "class VString : public std::string {\n");
        fprintf(vtypes_file, "public:\n");
        fprintf(vtypes_file, "    // Constructors\n");
        fprintf(vtypes_file, "    VString() : std::string() {}\n");
        fprintf(vtypes_file, "    VString(const std::string& str) : std::string(str) {}\n");
        fprintf(vtypes_file, "    VString(const char* str) : std::string(str) {}\n");
        fprintf(vtypes_file, "    VString(const VString& other) : std::string(other) {}\n\n");
        fprintf(vtypes_file, "    // String concatenation operator\n");
        fprintf(vtypes_file, "    VString operator+(const VString& other) const {\n");
        fprintf(vtypes_file, "        return VString(static_cast<const std::string&>(*this) + static_cast<const std::string&>(other));\n");
        fprintf(vtypes_file, "    }\n\n");
        fprintf(vtypes_file, "    // String repetition operator\n");
        fprintf(vtypes_file, "    VString operator*(int times) const {\n");
        fprintf(vtypes_file, "        VString result;\n");
        fprintf(vtypes_file, "        for (int i = 0; i < times; ++i) {\n");
        fprintf(vtypes_file, "            result += *this;\n");
        fprintf(vtypes_file, "        }\n");
        fprintf(vtypes_file, "        return result;\n");
        fprintf(vtypes_file, "    }\n\n");
        fprintf(vtypes_file, "    // Assignment operators\n");
        fprintf(vtypes_file, "    VString& operator+=(const VString& other) {\n");
        fprintf(vtypes_file, "        static_cast<std::string&>(*this) += other;\n");
        fprintf(vtypes_file, "        return *this;\n");
        fprintf(vtypes_file, "    }\n\n");
        fprintf(vtypes_file, "    VString& operator=(const VString& other) {\n");
        fprintf(vtypes_file, "        static_cast<std::string&>(*this) = other;\n");
        fprintf(vtypes_file, "        return *this;\n");
        fprintf(vtypes_file, "    }\n\n");
        fprintf(vtypes_file, "    // Stream output operator\n");
        fprintf(vtypes_file, "    friend std::ostream& operator<<(std::ostream& os, const VString& str) {\n");
        fprintf(vtypes_file, "        os << static_cast<const std::string&>(str);\n");
        fprintf(vtypes_file, "        return os;\n");
        fprintf(vtypes_file, "    }\n");
        fprintf(vtypes_file, "};\n\n");
        fprintf(vtypes_file, "}\n\n");
        fprintf(vtypes_file, "#endif\n");
        fclose(vtypes_file);
    }
}